"" Self-defined by minlin.zhang

"" Turn off syntax highlight if the line is too long
set synmaxcol=256

"" Show invisible chars
"  ref: https://www.reddit.com/r/vim/comments/4hoa6e/what_do_you_use_for_your_listchars/
set list
set listchars=tab:→\ ,nbsp:␣,trail:•,extends:⟩,precedes:⟨

" use '\\' to toggle between two files
nnoremap <Leader><Leader> <C-^>

"" Map semicolon to colon for inputing command
nmap ; :

"" paste mode toggle
set pastetoggle=<F9>

"" Reset <leader> key. Somehow it isn't working here, should modify it in .vimrc
let mapleader='\'

"" Window move keys
let g:C_Ctrl_j = 'off'
nnoremap <c-j> <c-w>j
nnoremap <c-k> <c-w>k
nnoremap <c-l> <c-w>l
nnoremap <c-h> <c-w>h

" moving aroung in command mode
cnoremap <c-h> <left>
cnoremap <c-j> <down>
cnoremap <c-k> <up>
cnoremap <c-l> <right>

"" vim-bufferkill
noremap <leader>c :BD<CR>

"" Remove trailing whitespace on <leader>S using vim-better-whitespace
nnoremap <leader>S :StripWhitespace<CR>


"" Jedi-VIM
" Using <C-n> other than <C-Space> in jedi-vim
let g:jedi#completions_command = "<C-n>"
let g:jedi#popup_on_dot = 1
let g:jedi#show_call_signatures = 1
" let g:jedi#use_tabs_not_buffers = 1

"" Python fold settings
set foldmethod=indent
set foldlevel=99

"" syntastic flake8
" Ignore E501 which is too long in line
let g:syntastic_python_flake8_args = '--ignore=E501'
nnoremap <leader>sc :SyntasticCheck<CR>
nnoremap <leader>sr :SyntasticReset<CR>

"" auto-pep8
nnoremap <leader>8 :Autopep8<CR>


"" Tagbar
map <leader>tb :TagbarToggle<CR>
let g:tagbar_autofocus=0
autocmd VimEnter * nested :call tagbar#autoopen(1)
" autocmd BufEnter * nested :call tagbar#autoopen(0)

"" NERDTree & vim-nerdtree-tabs
map <leader>tt :NERDTreeToggle<CR>
map <leader>tf :NERDTreeTabsFind<CR>
map <leader>tl :call <SID>NERDTreeTabsAutoLocateCodeFilesToggle()<CR>
let g:nerdtree_tabs_open_on_console_startup=1
let g:nerdtree_tabs_autofind=0

" self-defined variable. Set to 1 will auto locate code files in NERDTree
" during buffer/tab switching. Please set g:nerdtree_tabs_autofind=0 to avoid
" some conflicting issues.
let g:nerdtree_tabs_autolocate_code_files=1

function! s:NERDTreeTabsAutoLocateCodeFilesToggle()
  if g:nerdtree_tabs_autolocate_code_files != 1
    let g:nerdtree_tabs_autolocate_code_files = 1
  else
    let g:nerdtree_tabs_autolocate_code_files = 0
  endif
endfunction

"" Highlight current file in NERDTree: https://stackoverflow.com/a/42154947
" Check if NERDTree is open or active. Adding namespace "s:" to avoid conflicting.
function! s:isNERDTreeOpen()
  return exists("t:NERDTreeBufName") && (bufwinnr(t:NERDTreeBufName) != -1)
endfunction

" Call NERDTreeFind iff NERDTree is active, current window contains a modifiable
" file, and we're not in vimdiff
function! s:syncTree()
  " echom 'from zml, syncTree is called!'
  if g:nerdtree_tabs_autolocate_code_files != 1
    return
  endif

  if &modifiable && s:isNERDTreeOpen() && strlen(expand('%')) > 0 && !&diff
    NERDTreeTabsFind
    wincmd p
  endif
endfunction

" Highlight currently open buffer in NERDTree
" Note: use whitelist to only enable for some file types, or use blacklist to
" disable triggering "__Tagbar__.2" buffer
" autocmd BufEnter *[^_][^_][^Tt][^a][^g][^b][^a][^r][^_][^_].* call s:syncTree()
" autocmd BufEnter *.{py,java,c,h,cpp,md,sh} call s:syncTree()
autocmd BufEnter *.{py,java,c,h,cpp,md,sh} call s:syncTree()

"" indent for javascript and coffeescript
autocmd BufNewFile,BufRead *.js,*.ejs setlocal expandtab ts=2 sts=2 sw=2
autocmd BufNewFile,BufReadPost *.coffee setl shiftwidth=2 expandtab
autocmd BufNewFile,BufRead *.html setlocal expandtab ts=2 sts=2 sw=2


"" ------------ TLDR, the following is for neocomplete  ------------
" Note: This option must set it in .vimrc (_vimrc).
" NOT IN .gvimrc (_gvimrc)!
" Disable AutoComplPop.
let g:acp_enableAtStartup = 0
" Use neocomplete.
let g:neocomplete#enable_at_startup = 1
" Use smartcase.
let g:neocomplete#enable_smart_case = 1

" Define dictionary.
let g:neocomplete#sources#dictionary#dictionaries = {
	\ 'default' : '',
	\ 'vimshell' : $HOME.'/.vimshell_hist',
	\ 'scheme' : $HOME.'/.gosh_completions'
	\ }

" Define keyword.
if !exists('g:neocomplete#keyword_patterns')
	let g:neocomplete#keyword_patterns = {}
endif
let g:neocomplete#keyword_patterns['default'] = '\h\w*'

" Plugin key-mappings.
inoremap <expr><C-g>     neocomplete#undo_completion()
inoremap <expr><C-l>     neocomplete#complete_common_string()

" Recommended key-mappings.
" <CR>: close popup and save indent.
inoremap <silent> <CR> <C-r>=<SID>my_cr_function()<CR>
function! s:my_cr_function()
  " return (pumvisible() ? "\<C-y>" : "" ) . "\<CR>"
  " For no inserting <CR> key.  -- select this by zml
  return pumvisible() ? "\<C-y>" : "\<CR>"
endfunction

" <TAB>: completion.
inoremap <silent><expr> <TAB>
	  \ pumvisible() ? "\<C-n>" :
	  \ <SID>check_back_space() ? "\<TAB>" :
	  \ neocomplete#start_manual_complete()
function! s:check_back_space() abort "{{{
  let col = col('.') - 1
  return !col || getline('.')[col - 1]  =~ '\s'
endfunction"}}}

" <C-h>, <BS>: close popup and delete backword char.
inoremap <expr><C-h> neocomplete#smart_close_popup()."\<C-h>"
inoremap <expr><BS> neocomplete#smart_close_popup()."\<C-h>"
" Close popup by <Space>.
"inoremap <expr><Space> pumvisible() ? "\<C-y>" : "\<Space>"

" AutoComplPop like behavior.
"let g:neocomplete#enable_auto_select = 1

" Shell like behavior (not recommended.)
"set completeopt+=longest
"let g:neocomplete#enable_auto_select = 1
"let g:neocomplete#disable_auto_complete = 1
"inoremap <expr><TAB>  pumvisible() ? "\<Down>" :
" \ neocomplete#start_manual_complete()

" Enable omni completion.
autocmd FileType css setlocal omnifunc=csscomplete#CompleteCSS
autocmd FileType html,markdown setlocal omnifunc=htmlcomplete#CompleteTags
autocmd FileType javascript setlocal omnifunc=javascriptcomplete#CompleteJS
autocmd FileType python setlocal omnifunc=pythoncomplete#Complete
autocmd FileType xml setlocal omnifunc=xmlcomplete#CompleteTags

" Enable heavy omni completion.
if !exists('g:neocomplete#sources#omni#input_patterns')
  let g:neocomplete#sources#omni#input_patterns = {}
endif
if !exists('g:neocomplete#force_omni_input_patterns')
  let g:neocomplete#force_omni_input_patterns = {}
endif
"let g:neocomplete#sources#omni#input_patterns.php =
"\ '[^. \t]->\%(\h\w*\)\?\|\h\w*::\%(\h\w*\)\?'
"let g:neocomplete#sources#omni#input_patterns.c =
"\ '[^.[:digit:] *\t]\%(\.\|->\)\%(\h\w*\)\?'
"let g:neocomplete#sources#omni#input_patterns.cpp =
"\ '[^.[:digit:] *\t]\%(\.\|->\)\%(\h\w*\)\?\|\h\w*::\%(\h\w*\)\?'

" For perlomni.vim setting.
" https://github.com/c9s/perlomni.vim
let g:neocomplete#sources#omni#input_patterns.perl =
\ '[^. \t]->\%(\h\w*\)\?\|\h\w*::\%(\h\w*\)\?'


" by zml, neocomplete settings for java & python
let g:neocomplete#sources#omni#input_patterns.java = '[^. *\t]\.\w*\|\h\w*::'

autocmd FileType python setlocal omnifunc=jedi#completions
let g:jedi#completions_enabled = 0
let g:jedi#auto_vim_configuration = 0
let g:jedi#smart_auto_mappings = 0
let g:neocomplete#force_omni_input_patterns.python =
\ '\%([^. \t]\.\|^\s*@\|^\s*from\s.\+import \|^\s*from \|^\s*import \)\w*'
